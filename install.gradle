//Ref : https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle
//Ref : https://stackoverflow.com/questions/49207307/how-to-publish-all-flavor-variants-to-maven-with-android-gradle-plugin-3-0-0
//Ref : https://stackoverflow.com/questions/26874498/publish-an-android-library-to-maven-with-aar-and-source-jar
//Ref : https://proandroiddev.com/android-library-distribution-with-maven-publish-28ac59b8ecb8
//Ref : https://docs.gradle.org/current/userguide/publishing_customization.html
//Ref : https://kotlinlang.org/docs/mpp-publish-lib.html#publish-an-android-library
//Ref : https://alessiobianchi.eu/blog/obfuscated-aar-local-maven/
//Ref : https://gist.github.com/zhang-xue-feng/02aeb0ecebd5e4767f3d
//Ref : https://www.py4u.net/discuss/612809
//Ref : https://github.com/palantir/gradle-git-version
//Ref : https://github.com/n0mer/gradle-git-properties
//Ref : https://juejin.im/post/6844904144386392071
//https://www.jianshu.com/p/960a60a84339
apply plugin: 'maven-publish'
version = this.project.version
group = this.project.group

def pomArtifactId = this.archivesBaseName.replace("-", "_")
tasks.withType(Javadoc).all { enabled = false }

def checkIsAndroidProject() {
    def plugins = project.getPlugins()
    return plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')
}
def isToGit = this.ext.has("isToGit")

if (checkIsAndroidProject()) {
    task androidJavadocs(type: Javadoc) {
        description "Generates Javadoc"
        source = android.sourceSets.main.java.srcDirs
        classpath += files(android.bootClasspath)

        android.libraryVariants.all { variant ->
            if (variant.name.contains("release")) {
                owner.classpath += variant.javaCompileProvider.get().classpath
            }
        }
        exclude '**/R.html', '**/R.*.html', '**/index.html', '**/*.kt'
        options {
//            windowTitle("${getStringProperty("mavProjectName")} ${project.version} Reference")
            locale = 'en_US'
            encoding = 'UTF-8'
            charSet = 'UTF-8'
            links("http://docs.oracle.com/javase/7/docs/api/")
            linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference")
            setMemberLevel(JavadocMemberLevel.PUBLIC)
        }
    }

//    def jniSymbolsJar = task("${variant.name}SymbolJar", type: Jar, dependsOn: 'build') {
//        classifier = "so-symbols"
//        boolean hasNativeBuildTask = false
//        tasks.each { task ->
//            if (task.getName().startsWith("externalNativeBuild")) {
//                hasNativeBuildTask = true
//            }
//        }
//
//        if (!hasNativeBuildTask) {
//            return
//        }
//
//        if (hasFlavors) {
//            variant.productFlavors.each { flavor ->
//                from file("build/intermediates/cmake/${flavor.name}/release/obj/")
//            }
//        } else {
//            from file("build/intermediates/cmake/release/obj/")
//        }
//
//    }

    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
        classifier = 'javadoc'
        baseName = pomArtifactId
        from androidJavadocs.destinationDir
    }

    task androidSourcesJar(type: Jar) {
        classifier = 'sources'
        baseName = pomArtifactId
        from android.sourceSets.main.java.srcDirs
    }
} else { //Here is pure java
    tasks.withType(JavaCompile) { //Here is pure java
        options.encoding = 'UTF-8'
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        archiveClassifier = 'javadoc'
        baseName = pomArtifactId
        from javadoc.destinationDir
    }
}

publishing {
    publications {
        if (checkIsAndroidProject()) {
            android.libraryVariants.all { variant ->
                def flavor_with_buildtype = variant.name.capitalize()
                def hasFlavors = !variant.flavorName.isEmpty()
                def build_type = variant.buildType.name
                def artifactIdSuffix = hasFlavors ? variant.flavorName.replace('_', '-').capitalize() : pomArtifactId
                def publicationName = "${variant.name.capitalize()}"
                variant.outputs.all {
                    outputFileName = outputFileName.replace("-", "_")
                }
                variant.productFlavors.each { flavor ->
                    def flavorArtifactIdSuffix = flavor.ext.has('artifactIdSuffix') ? flavor.ext.artifactIdSuffix : flavor.name
                    if (!flavorArtifactIdSuffix.isEmpty()) {
                        artifactIdSuffix = artifactIdSuffix.replace(flavor.name.capitalize(), "${flavorArtifactIdSuffix}")
                    } else {
                        artifactIdSuffix = artifactIdSuffix.replace(flavor.name.capitalize(), "")
                    }
                }

                "$publicationName"(MavenPublication) {
                    groupId = this.project.group
                    artifactId "${this.archivesBaseName.replace("-", "_")}_$publicationName"
                    version = this.project.version
                    artifact androidJavadocsJar
                    artifact androidSourcesJar
                    def taskname = "bundle" + flavor_with_buildtype.substring(0, 1).toUpperCase() + flavor_with_buildtype.substring(1) + "Aar"
                    def archivetask = variant.outputs[0].packageLibrary
                    artifact archivetask
                    decoratePom(pom)
                }
            }
        } else {
            mavenJava(MavenPublication) {
                println("Maven publish : Java Type")
                from components.java
                artifact sourcesJar
                artifact javadocJar
                pom {
                    name = pomArtifactId
                    description = this.ext.mavLibraryDescription
                    url = this.ext.mavSiteUrl
                    properties = [
                            myProp          : "value",
                            "prop.with.dots": "anotherValue"
                    ]
                    // Set your license
                    licenses {
                        license {
                            this.ext.mavLibraryLicenses.each { key, value ->
                                name = key
                                url = value
                            }
                        }
                    }
                    developers {
                        developer {
                            id = this.ext.developerid
                            name = this.ext.developername
                            email = this.ext.developeremail
                        }
                    }
                    scm {
                        connection = this.ext.scmConnectionUrl
                        developerConnection = this.ext.scmDeveloperConnectionUrl
                        url = this.ext.scmUrl
                    }
                }
            }
        }
    }

    repositories {
        if (isToGit) {
            maven {
                url = "file:///${this.project.rootProject.rootDir}/maven-repository"
            }
        }
        File f = this.file('sonatype_nexus.properties')
        def from_stream = project.ext.has("maven_properties_file")
        def from_local_file = (f.exists() && !f.isDirectory())
        def from_ext = project.ext.has("Sonatype_NexusUrl_Url")
        Properties props = new Properties()
        if (from_stream) {
            def properties_file = project.ext.get("maven_properties_file")
            props.load(new URL(properties_file).openStream())
            def maven_url_path = props['sonatype.path'].trim()
            def repo_name = props['sonatype.repo.name'].trim()
            maven {
                name 'Sonatype_Nexus'
                url maven_url_path + repo_name
                if (!maven_url_path.contains("https")) {
                    allowInsecureProtocol = true
                }
                credentials {
                    username props['sonatype.user']
                    password props['sonatype.password']
                }
            }
        } else if (from_local_file) {
            props.load(new FileInputStream(f))
            def maven_url_path = props['sonatype.path'].trim()
            def repo_name = props['sonatype.repo.name'].trim()
            maven {
                name 'Sonatype_Nexus'
                url maven_url_path + repo_name
                if (!maven_url_path.contains("https")) {
                    allowInsecureProtocol = true
                }
                credentials {
                    username props['sonatype.user']
                    password props['sonatype.password']
                }
            }
        } else if (from_ext && from_local_file) {
            props.load(new FileInputStream(f))
            def maven_url_path = this.ext.Sonatype_NexusUrl_Url
            maven {
                name 'Sonatype_Nexus'
                url this.ext.Sonatype_NexusUrl_Url
                if (!maven_url_path.contains("https")) {
                    allowInsecureProtocol = true
                }
                credentials {
                    username props['sonatype.user']
                    password props['sonatype.password']
                }
            }
        }
    }
}

def decoratePom(pom) {
    pom.name = this.archivesBaseName.replace("-", "_")
    pom.description = this.ext.mavLibraryDescription
    pom.url = this.ext.mavSiteUrl
    pom.inceptionYear = new Date().format("yyyy-MM-dd").toString()

    pom.licenses {
        license {
            this.ext.mavLibraryLicenses.each { key, value ->
                name = key
                url = value
            }
        }
    }

    pom.developers {
        developer {
            id = this.ext.developerid
            name = this.ext.developername
            email = this.ext.developeremail
        }
    }
    pom.scm {
        connection = this.ext.scmConnectionUrl
        developerConnection = this.ext.scmDeveloperConnectionUrl
        url = this.ext.scmUrl
    }
    addDependencies(pom)
}

def addDependencies(pom) {
    pom.withXml {
        final dependenciesNode = asNode().appendNode('dependencies')
        ext.addDependency = { Dependency dep, String scope ->
            if (dep.group == null || dep.version == null || dep.name == null || dep.name == "unspecified" || dep.version == "unspecified")
                return // ignore invalid dependencies

            if (dep.artifacts.size() > 0) {
                dep.artifacts.each { art ->
                    addDependencyNode(dependenciesNode, dep, scope, art.classifier, art.extension)
                }
            } else {
                addDependencyNode(dependenciesNode, dep, scope, null, null)
            }
        }
        manageConfigurations(configurations)
    }
}

def manageConfigurations(configurations) {
    def gradle_main_version = Integer.parseInt(gradle.gradleVersion.toString().split("\\.")[0])
    if (gradle_main_version > 6) {
        if (!checkIsAndroidProject()) {
            configurations.implementation.getDependencies().each { dep -> addDependency(dep, "runtime") }
            configurations.runtime.getDependencies().each { dep -> addDependency(dep, "runtime") }
            configurations.testRuntime.getDependencies().each { dep -> addDependency(dep, "test") }
        } else {
            configurations.api.getDependencies().each { dep -> addDependency(dep, "compile") }
            configurations.implementation.getDependencies().each { dep -> addDependency(dep, "compile") }
            configurations.compileOnly.getDependencies().each { dep -> addDependency(dep, "runtime") }
        }
        configurations.testImplementation.getDependencies().each { dep -> addDependency(dep, "test") }
    } else {
        configurations.compile.getDependencies().each { dep -> addDependency(dep, "compile") }
        configurations.testCompile.getDependencies().each { dep -> addDependency(dep, "test") }
    }
}

//Ref : https://stackoverflow.com/questions/32998716/maven-publish-cannot-not-apply-withxml-on-pom-file-no-signature-of-method
def addDependencyNode(dependenciesNode, dep, scope, classifier, extension) {
    final dependencyNode = dependenciesNode.appendNode('dependency')
    dependencyNode.appendNode('groupId', dep.group)
    dependencyNode.appendNode('artifactId', dep.name)
    dependencyNode.appendNode('version', dep.version)

    if (classifier != null) {
        dependencyNode.appendNode('classifier', classifier)
    }

    if (extension != null) {
        dependencyNode.appendNode('type', extension)
    }

    dependencyNode.appendNode('scope', scope)

    if (!dep.transitive) {
        // If this dependency is transitive, we should force exclude all its dependencies them from the POM
        final exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
        exclusionNode.appendNode('artifactId', '*')
        exclusionNode.appendNode('groupId', '*')
    } else if (!dep.properties.excludeRules.empty) {
        // Otherwise add specified exclude rules
        final exclusionsNode = dependencyNode.appendNode('exclusions')
        dep.properties.excludeRules.each { ExcludeRule rule ->
            final exclusionNode = exclusionsNode.appendNode('exclusion')
            exclusionNode.appendNode('artifactId', rule.module ?: '*')
            exclusionNode.appendNode('groupId', rule.group ?: '*')
        }
    }
}